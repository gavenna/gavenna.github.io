






[{"content":"","date":"2024-08-07","externalUrl":null,"permalink":"/docs/","section":"Docs","summary":"","title":"Docs","type":"docs"},{"content":" 递归练习总结\n优先考虑递归结束情况(避免无限递归)（常用于解决最后一次运算） 递归途中情况（常用于n-1次运算） 递归尾部情况（常用于n-1次运算）（考虑带参） 递归实际上是一种栈的思想，先进后出，在代码运行上按照“先进后出”思考即可 (1) if() return (2) (3) return\n单链表 # typedef int ElemType ;//数据元素的类型 typedef struct node { ElemType data; //“数据域”：保存数据 struct node* next; //“指针域”：保存下一个元素的地址 } Node; 双向链表 # typedef int ElemType; //数据元素的类型 typedef struct BiNode { ElemType data; //“数据域”：保存结点的数据 struct BiNode* next; //“指针域”: next 指向下一个结点 struct BiNode* prev; //“指针域”：prev 指向上一个结点 }BiNode; (1) 写一个函数，删除整个单链表。 用递归 # void digui_dele(Node **h) { if (*h == NULL) { return; } Node *p = *h; *h = p-\u0026gt;next; p-\u0026gt;next = NULL; free(p); digui_dele(h); //free(*h);free(NULL)也是安全的，若为空，则不进行如何操作返回 return; } (2) 写一个函数，逆序输出单链表上每个结点的值。用递归 # void digui_print(Node **h) { // printf(\u0026#34;0000\\n\u0026#34;); if ((*h)-\u0026gt;next == NULL) { printf(\u0026#34;---\\n\u0026#34;); printf(\u0026#34;%d \u0026#34;, (*h)-\u0026gt;data); return; } // printf(\u0026#34;0000\\n\u0026#34;); Node *p = *h; *h = (*h)-\u0026gt;next; digui_print(h); // printf(\u0026#34;%d \u0026#34;, (*h)-\u0026gt;data); if (p-\u0026gt;next = *h) { printf(\u0026#34;%d \u0026#34;, p-\u0026gt;data); } return; } (3) 写一个函数，求一个单链表的结点数目。 用递归 # int digui_numscal(Node **h, int a) { if ((*h)-\u0026gt;next == NULL) { a++; return a; } Node *p = *h; *h = (*h)-\u0026gt;next; a = digui_numscal(h, a); a++; return a; } (4) 写一个函数，就地逆置一个单链表 # Node *digui_nizhi(Node **h) { if ((*h)-\u0026gt;next == NULL) { return NULL; } Node *k = NULL; Node *pr = *h; *h = (*h)-\u0026gt;next; k = digui_nizhi(h); if (k == NULL) { k = *h; } (*h)-\u0026gt;next = pr; pr-\u0026gt;next = NULL; *h = pr; //未更新尾指针指向导致错位，用gdb调试解决 return k; } ","date":"2024-08-07","externalUrl":null,"permalink":"/docs/docs/list/","section":"Docs","summary":"递归链表练习","title":"List","type":"docs"},{"content":"","date":"2024-08-07","externalUrl":null,"permalink":"/tags/space/","section":"Tags","summary":"","title":"Space","type":"tags"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/en/","section":"Blowfish","summary":"","title":"Blowfish","type":"page"},{"content":"","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]